
load('/nesi/project/uoa03821/FLGI/two_arms/flgi0_0_995.Rdata')
library(dplyr)
library(parallel)
#### Functions adapted from http://github.com/kwathen/IntroBayesianSimulation.
#### SimulateAMonthOfAccrualTimes, SimulateArrivalTimes: These function simulates
#### a month of recruitment times.
#### SimulateOutcomeObservedTime: This function simulates the time the patient
#### outcomes are observed.
#### Note: The accrual time not necessarily to be a month, it could be a week
#### or whatever time frame it could be. But when the unit changes, the number in
#### vTimeToOutcome1 (eg: 1 and 0.2 in rnorm( length( vStartTime ),1, 0.2)) in
#### the SimulateOutcomeObservedTime should be changed as well.
#### Refer to the website for more details.

SimulateAMonthOfAccrualTimes <- function( dPatsPerMonth , dStartMonth )
{
  nQtyPats    <- 1.2 *qpois(0.9999,dPatsPerMonth)
  vTimes      <- cumsum( rexp( nQtyPats, dPatsPerMonth ) )
  vTimes      <- vTimes[ vTimes < 1 ]
  vTimes      <- vTimes + dStartMonth
  return( vTimes )
}

SimulateArrivalTimes <- function( vPatsPerMonth, nMaxQtyPats )
{
  vTimes <- c()
  if( length( vPatsPerMonth ) == 1 )
  {
    vTimes <- cumsum(rexp(nMaxQtyPats ,vPatsPerMonth))
  }
  else
  {
    dStartMonth <- 0
    nMonth     <- 1
    while( length( vTimes ) < nMaxQtyPats  )
    {
      vTimes      <- c( vTimes, SimulateAMonthOfAccrualTimes( vPatsPerMonth[ nMonth ], dStartMonth ))
      dStartMonth <- dStartMonth + 1

      if( nMonth < length( vPatsPerMonth ) )
        nMonth <- nMonth +  1
    }
    vTimes <- vTimes[ 1:nMaxQtyPats ]
  }
  return( vTimes )
}

SimulateOutcomeObservedTime <- function( vStartTime, vTimeToOutcome1)
{
  vTimeToOutcome <-eval(vTimeToOutcome1)
  vObsTime <- vStartTime  + vTimeToOutcome
  return( vObsTime )
}

#### Function of the simulated populations with return of the
#### start time of all patients, the maximal accrued number of patients and
#### start time of patients enrolled  in the trial.
#### vPatsPerMonth: the number of patients accrued within a certain time frame.
#### nMaxQtyPats: the maximal accrued number of patients having disease, this number
#### should be chosen carefully to make sure there are enough patients for the
#### calculation of patients in the population.
#### enrollrate: the probability that patients in the population can enroll into the trial.
pop<-function(vPatsPerMonth,nMaxQtyPats,enrollrate1){
  populationtotal<-SimulateArrivalTimes (vPatsPerMonth, nMaxQtyPats)
  vStartTime1<-rbinom(nMaxQtyPats,size=1,enrollrate1)
  vStartTime2<- cbind(vStartTime1,populationtotal)
  vStartTime3<-vStartTime2[vStartTime2[,1]==1,]
  return(list(populationtotal,length(populationtotal),as.vector(vStartTime3[,2])))
}

#### Function of the simulated allocation probabilities for each patient to
#### different treatment arm in the current block with the return of
#### allocation probabilities for each patient in the current block.
#### tt: the accumulated blocks till this block.
#### data1: the simulated data set with available information at this block.
#### K1: number of total treatment arms.
#### I0: matrix with K rows and 1 column, with row number and the numbers inside
#### equal to the number of total treatment arms.
#### block: block size
#### noRuns: Number of simulations, Villar et al. used 100 times.
#### rule: 'FLGI PM' stands for making decision based on posterior mean;
#### 'FLGI PD' stands for making decision based on posterior distribution.
allocation_probabilities<-function(tt,data1,K1,I0,block,noRuns,rule){

  index<-matrix(0,nrow=K1,1)
  selected<-matrix(0,nrow=noRuns,block)
  prob<-matrix(0,K1,block)

  for (j in 1:noRuns) {
    n=matrix(rowSums(I0)+2,nrow=nrow(I0),1)
    s=matrix(I0[,1]+1,nrow=nrow(I0),1)
    f=matrix(I0[,2]+1,nrow=nrow(I0),1)

    for (t1 in 0: (block-1)){
      for (k in 1:K1){
        index[k,1]=Gittins[f[k,1],s[k,1]]
      }
      max_index=max(index)
      kmax=min(match(max(index), index))
      idx= which(as.vector(index)==max(index))

      if (length(idx)>1){
        posi=sample(1:length(idx),1)
        kmax=idx[posi]
        max_index=as.vector(index)[kmax]
      }
      selected[j,t1+1]=kmax
      snext=s
      fnext=f
      nnext=n

      if (rule=='FLGI PM' |rule=='Controlled FLGI'){
        probSuc_kmax=s[kmax,1]/(s[kmax,1]+f[kmax,1])
        if(runif(1)<=probSuc_kmax){
          Pos=1
        }else{
          Pos=0
        }
      }else if (rule=='FLGI PD'){
        probSuc_kmax=rbeta(1,s[kmax,1],f[kmax,1])
        Pos= rbinom(1,1,probSuc_kmax)
      }
      nnext[kmax,1]=n[kmax,1]+1

      data1[tt*block+t1+1,4]=kmax
      data1[tt*block+t1+1,5]=Pos
      total1<-sum(as.numeric(data1[,3])<=as.numeric(data1[tt*block+t1+1,2]))

      for (k in 1:K1){
        if (total1>0){
          dataa<-matrix(data1[which(as.numeric(data1[,3])<=as.numeric(data1[tt*block+t1+1,2])),],ncol=5)
          snext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==1,,drop=F])+2
          fnext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==0,,drop=F])+2

        }else if (total1==0){
          snext[k,1]=s[k,1]
          fnext[k,1]=f[k,1]
        }
      }

      s=snext
      f=fnext
      n=nnext
    }
  }

  for (i in 1:block){
    for(k in 1:K1){
      prob[k,i]=sum(selected[,i]==k)/noRuns
    }
  }

  allocation_probabilities=rowMeans(prob)

  return(allocation_probabilities)
}

#### Function of the simulated allocation probabilities for each patient to
#### different treatment arm in the current block for CFLGI with the return of
#### allocation probabilities for each patient in the current block.
#### tt: the accumulated blocks till this block.
#### data1: the simulated data set with available information at this block.
#### K1: number of total treatment arms.
#### I0: matrix with K rows and 1 column, with row number and the numbers inside
#### equal to the number of total treatment arms.
#### block: block size
#### noRuns: Number of simulations, Villar et al. used 100 times.
#### rule: 'FLGI PM' stands for making decision based on posterior mean;
#### 'FLGI PD' stands for making decision based on posterior distribution.
allocation_probabilities1<-function(tt,data1,K1,I0,block,noRuns,rule){

  index<-matrix(0,nrow=K1,1)
  selected<-matrix(0,nrow=noRuns,block)
  prob<-matrix(0,K1,block)

  for (j in 1:noRuns) {
    n=matrix(rowSums(I0)+2,nrow=nrow(I0),1)
    s=matrix(I0[,1]+1,nrow=nrow(I0),1)
    f=matrix(I0[,2]+1,nrow=nrow(I0),1)

    for (t1 in 0: (block-1)){
      for (k in 1:K1){
        index[k,1]=Gittins[f[k,1],s[k,1]]
      }
      max_index=max(index)
      kmax=min(match(max(index), index))
      idx= which(as.vector(index)==max(index))
      if (length(idx)>1){
        posi=sample(1:length(idx),1)
        kmax=idx[posi]
        max_index=as.vector(index)[kmax]
      }
      selected[j,t1+1]=kmax
      snext=s
      fnext=f
      nnext=n
      if (rule=='FLGI PM'|rule=='Controlled FLGI'){
        probSuc_kmax=s[kmax,1]/(s[kmax,1]+f[kmax,1])
        if(runif(1)<=probSuc_kmax){
          Pos=1
        }else{
          Pos=0
        }
      }else if (rule=='FLGI PD'){
        probSuc_kmax=rbeta(1,s[kmax,1],f[kmax,1])
        Pos= rbinom(1,1,probSuc_kmax)
      }
      nnext[kmax,1]=n[kmax,1]+1
      data1[tt*block+t1+1,4]=kmax+1
      data1[tt*block+t1+1,5]=Pos
      total1<-sum(as.numeric(data1[,3])<=as.numeric(data1[tt*block+t1+1,2]))

      for (k in 1:K1){
        if (total1>0){
          dataa<-matrix(data1[which(as.numeric(data1[,3])<=as.numeric(data1[tt*block+t1+1,2])),],ncol=5)
          snext[k,1]=nrow(dataa[dataa[,4]==k+1 & dataa[,5]==1,,drop=F])+2
          fnext[k,1]=nrow(dataa[dataa[,4]==k+1 & dataa[,5]==0,,drop=F])+2

        }else if (total1==0){
          snext[k,1]=s[k,1]
          fnext[k,1]=f[k,1]
        }
      }
      s=snext
      f=fnext
      n=nnext
    }
  }

  for (i in 1:block){
    for(k in 1:K1){
      prob[k,i]=sum(selected[,i]==k)/noRuns
    }
  }

  allocation_probabilities=rowMeans(prob)

  return(allocation_probabilities)
}

#### Function of FLGI/CFLGI simulations with return of the actual allocated treatment
#### for all patients in the trial, patients' results in the trial, one-sided test
#### decision made by z-test, decision made by gittin index, total sample size,
#### a 5 column data set (patient ID number, enrolled time, observed time of results,
#### allocated treatment arm, patients' results), two-sided test decision made by z-test,
#### the z test statistics.
#### datapop: data simulated from pop function.
#### jj: the index of the specified enroll rate.
#### x: the iteration number of the specified enroll rate.
#### I0: matrix with K rows and K column, with the numbers inside equal to 1 and
#### K equal to the total number of treatment arms.
#### tt: the accumulated blocks till this block.
#### data1: the simulated data set with available information at this block.
#### K1: number of total treatment arms.
#### crit: type I error.
#### noRuns2: Number of simulations for simulated allocation probabilities, Villar et al. used 100 times.
#### noRuns: default equal to 1, and no need to update.
#### Tsize: total sample size
#### ptrue: real proportions of success for the binary outcome.
#### block: block size
#### rule: 'FLGI PM' stands for making decision based on posterior mean;
#### 'FLGI PD' stands for making decision based on posterior distribution;
#### 'CFLGI' stands for CFLGI.
#### ztype: pooled or unpooled z statistics.
simflgi<-function(datapop=sim11,jj,x,vTimeToOutcome1,I0,K,crit,noRuns2,noRuns=1,Tsize,ptrue,block,rule,ztype){#criteria,

  index<-matrix(0,nrow=K,1)
  phat<-matrix(0,nrow=noRuns,K)
  sigmahat<-matrix(0,nrow=noRuns,K)
  ns<-matrix(0,nrow=noRuns,K)
  sn<-matrix(0,nrow=noRuns,K)
  zs1<-matrix(0,nrow=noRuns,K-1)
  #  pv<-matrix(0,nrow=noRuns,K-1)
  #  pv0<-matrix(0,nrow=noRuns,K-1)
  #  zp1<-matrix(0,nrow=noRuns,K-1)
  #  pvalues1<-matrix(0,nrow=noRuns,K-1)
  #  pvaluep1<-matrix(0,nrow=noRuns,K-1)
  #  pbetter<-matrix(0,nrow=noRuns,K-1)
  selected<-matrix(0,nrow=Tsize,noRuns)
  ntreat<-matrix(0,nrow=noRuns,K)
  ap<-matrix(0,nrow=noRuns,K-1)
  besteffect<-max(ptrue)
  besttreat<-min(match(max(ptrue), ptrue))
  vStartTime<-sort(datapop[[jj]][[x]][[3]][1:Tsize], decreasing = FALSE)
  vOutcomeTime<-SimulateOutcomeObservedTime(vStartTime,vTimeToOutcome1)
  data1<-matrix(NA_real_,nrow=Tsize,ncol=5)
  data1[,1]<-1:Tsize
  data1[,2]<-vStartTime
  data1[,3]<-vOutcomeTime

  n=matrix(rowSums(I0)+2,nrow=nrow(I0),1)
  s=matrix(I0[,1]+1,nrow=nrow(I0),1)
  f=matrix(I0[,2]+1,nrow=nrow(I0),1)

  for (t in 0:((Tsize/block)-1)){

    alp=allocation_probabilities(tt=t,data1=data1,I0=cbind(s-1,f-1),block=block,noRuns=noRuns2,K1=K,rule=rule)
    # if (rule=='FLGI PM' |rule=='FLGI PD'  ){
    #   crit=0.056
    #   if (K>2 & block>1){
    #     crit=0.05
    #   }else if (K>2 & block==1){
    #     crit=0.06
    #   }
    #   crit=(K-1)*crit
    # }
    if (rule=='Controlled FLGI'  ){
      alp[1]=1/(K-1)
      elp_e=allocation_probabilities1(tt=t,data1=data1,I0=cbind(s[2:K,]-1,f[2:K,]-1),block=block,noRuns=noRuns2,K1=K-1,rule='FLGI PM')
      c=alp[1]+sum(elp_e)
      alp=(1/c)*c(alp[1],elp_e)
    }
    # if (rule=='Controlled FLGI modified'  ){
    #   elp=allocation_probabilities(tt=t,data1=data1,I0=cbind(s-1,f-1),block=block,K1=K,noRuns=noRuns2,rule='FLGI PM')
    #   alp[1]=max(1/(K-1),min(elp[1],(1-1/(K-1))))
    #   elp_e=allocation_probabilities1(tt=t,data1=data1,I0=cbind(s[2:K,]-1,f[2:K,]-1),block=block,noRuns=noRuns2,K1=K-1,rule='FLGI PM')
    #   c=alp[1]+sum(elp_e)
    #   alp=(1/c)* c(alp[1],elp_e)
    # }

    alp=cumsum(c(0,alp))

    snext=s
    fnext=f
    nnext=n

    Pob<-rep(0,block)
    Pos<-rep(0,block)
    for (p in 1:block){
      Pob[p]<-runif(1)
      for (k in 1:K){
        if (Pob[p]>alp[k] & Pob[p]<=alp[k+1]){
          nnext[k]=n[k]+1
          if (runif(1)<=ptrue[k]){
            Pos[p]=1
          }else{
            Pos[p]=0
          }
          data1[t*block+p,4]=k
          data1[t*block+p,5]=Pos[p]

          total1<-sum(as.numeric(data1[,3])<=as.numeric(data1[t*block+p,2]))
          if (total1>0){

            dataa<-matrix(data1[which(as.numeric(data1[,3])<=as.numeric(data1[t*block+p,2])),],ncol=5)
            snext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==1,,drop=F])+2
            fnext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==0,,drop=F])+2
          }else if (total1==0){
            snext[k,1]=s[k,1]
            fnext[k,1]=f[k,1]
          }
        }
      }
      s=snext
      f=fnext
      n=nnext
    }
  }

  if (floor(Tsize/block)*block!=Tsize){
    Pob<-rep(0,Tsize-floor(Tsize/block)*block)
    Posi<-rep(0,Tsize-floor(Tsize/block)*block)
    for (p in 1:(Tsize-floor(Tsize/block)*block)){
      Pob[p]<-runif(1)
      for (k in 1:K){
        if (Pob[p]>alp[k] & Pob[p]<=alp[k+1]){
          nnext[k]=n[k]+1

          if (runif(1)<=ptrue[k]){
            Posi[p]=1
          }else {
            Posi[p]=0
          }
          data1[floor(Tsize/block)*block+p,4]=k
          data1[floor(Tsize/block)*block+p,5]=Posi[p]

          total1<-sum(as.numeric(data1[,3])<=as.numeric(data1[floor(Tsize/block)*block+p,2]))
          if (total1>0){

            dataa<-matrix(data1[which(as.numeric(data1[,3])<=as.numeric(data1[floor(Tsize/block)*block+p,2])),],ncol=5)
            snext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==1,,drop=F])+2
            fnext[k,1]=nrow(dataa[dataa[,4]==k & dataa[,5]==0,,drop=F])+2
          }else if (total1==0){
            snext[k,1]=s[k,1]
            fnext[k,1]=f[k,1]
          }

        }
      }
      s=snext
      f=fnext
      n=nnext
    }
  }

  for (k in 1:K){
    s[k,1]=nrow(data1[data1[,4]==k & data1[,5]==1,,drop=F])+2
    f[k,1]=nrow(data1[data1[,4]==k & data1[,5]==0,,drop=F])+2
    n[k,1]=nrow(data1[data1[,4]==k ,,drop=F])+4
  }


  ns[1,]=n-2
  sn[1,]=s-1
  phat[1,]=(s-1)/(n-2)

  if (ztype=='unpooled'){
    sigmahat[1,]=(phat[1,]*(1-phat[1,]))/ns[1,]
  } else if (ztype=='pooled'){
    for (k in 2:K){
      sigmahat[1,k]= (sum(sn[1]+sn[k])/sum(ns[1]+ns[k]))*
        (1-(sum(sn[1]+sn[k])/sum(ns[1]+ns[k])))*
        (1/ns[1] +1/ns[k])
    }
  }


  sigma<-matrix(0,K-1,K-1)
  sigmat<-matrix(0,K-1,K-1)
  pc<-matrix(0,1,K-1)

  for (k in 1:(K-1)){
    # pv[1,k]=phyper(sn[1,k+1]-1,sn[1,1]+sn[1,k+1],ns[1,1]+ns[1,k+1]-sn[1,1]-sn[1,k+1],ns[1,k+1])
    # pv0[1,k]=phyper(sn[1,1]-1,sn[1,1]+sn[1,k+1],ns[1,k+1]+ns[1,1]-sn[1,1]-sn[1,k+1],ns[1,1])
    if (ztype=='unpooled'){
      zs1[1,k]=(phat[1,k+1]-phat[1,1])/sqrt(sigmahat[1,1]+sigmahat[1,k+1])
    } else if (ztype=='pooled'){
      zs1[1,k]=(phat[1,k+1]-phat[1,1])/sqrt(sigmahat[1,k+1])
    }
  }

  return(zs1)

}


##################### Simulations #####################
enrollratef<-c(0.1,0.5,0.9)
perctp<-0.5
perctt1<-c(0,0.1,0.2,0.3,0.4,0.5)
repn<-20000
sim11<-vector("list",length(enrollratef))
for (jj in (1:length(enrollratef))){
  seeds<-1:repn
  sim11[[jj]]<-lapply(1:repn,function(x) {
    set.seed(seeds[x])
    pop(vPatsPerMonth=10,nMaxQtyPats=50000,enrollrate1=enrollratef[jj])})
}#if there are 5000 patients in the trial, how many patients will have disease in the population



ncpus <- as.numeric(Sys.getenv("SLURM_CPUS_PER_TASK"))
cluster <-makeCluster(ncpus)

# simnull1<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=552,ptrue=c(0.15,0.15),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull1,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull1.Rdata')
# #sum(do.call(rbind,simnull1)[,1]>1.968)/20000 0.025
#
#
# ###############
#
# simnull2<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=168,ptrue=c(0.2,0.2),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull2,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull2.Rdata')
# #sum(do.call(rbind,simnull2)[,1]>1.87508)/20000 0.02505
#
#
#
# ###############
#
# simnull3<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=816,ptrue=c(0.25,0.25),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull3,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull3.Rdata')
# #sum(do.call(rbind,simnull3)[,1]>1.962)/20000 0.025
#
#
# ###############
#
# simnull4<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=224,ptrue=c(0.3,0.3),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull4,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull4.Rdata')
# #sum(do.call(rbind,simnull4)[,1]>1.961)/20000 0.025
#
# ###############
#
# simnull5<-parallel::mclapply(1:repn,function(x) {
#   #  print(x)
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=100,ptrue=c(0.35,0.35),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull5,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull5.Rdata')
# #sum(do.call(rbind,simnull5)[,1]>1.8782)/20000 0.02495
#
#
# ###############
#
# simnull6<-parallel::mclapply(1:repn,function(x) {
#   #  print(x)
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=992,ptrue=c(0.35,0.35),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull6,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull6.Rdata')
# #sum(do.call(rbind,simnull6)[,1]>1.983)/20000 0.025
#
#
# ###############
#
# simnull7<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=256,ptrue=c(0.4,0.4),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull7,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull7.Rdata')
# #sum(do.call(rbind,simnull7)[,1]>1.948)/20000 0.025
#
#
# ###############
#
# simnull8<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=114,ptrue=c(0.45,0.45),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull8,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull8.Rdata')
# #sum(do.call(rbind,simnull8)[,1]>1.933)/20000 0.025
#
#
#
# #############
#
# simnull9<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=1080,ptrue=c(0.45,0.45),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull9,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull9.Rdata')
# #sum(do.call(rbind,simnull9)[,1]>1.99)/20000 0.025
#
#
# #############
#
# simnull10<-parallel::mclapply(1:repn,function(x) {
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=264,ptrue=c(0.5,0.5),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull10,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull10.Rdata')
# #sum(do.call(rbind,simnull10)[,1]>1.9841)/20000 0.025
#
#
# ###########
#
# simnull11<-parallel::mclapply(1:repn,function(x) {
#   # print(x)
#   simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
#           Tsize=114,ptrue=c(0.55,0.55),block=20,rule='Controlled FLGI',ztype='unpooled')
# },mc.cores = 66)
#
# save(simnull11,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull11.Rdata')
# #sum(do.call(rbind,simnull11)[,1]>1.956)/20000 0.025
#

############################

simnull12<-parallel::mclapply(1:repn,function(x) {
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=1080,ptrue=c(0.55,0.55),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull12,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull12.Rdata')
#sum(do.call(rbind,simnull12)[,1]>1.9498)/20000 0.025


############################

simnull13<-parallel::mclapply(1:repn,function(x) {
  # print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=256,ptrue=c(0.6,0.6),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull13,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull13.Rdata')
#sum(do.call(rbind,simnull13)[,1]>1.9956)/20000 0.025


############################

simnull14<-parallel::mclapply(1:repn,function(x) {

  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=100,ptrue=c(0.65,0.65),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull14,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull14.Rdata')
#sum(do.call(rbind,simnull14)[,1]>1.9865)/20000 0.02505


############################

simnull15<-parallel::mclapply(1:repn,function(x) {
  # print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=992,ptrue=c(0.65,0.65),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull15,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull15.Rdata')
#sum(do.call(rbind,simnull15)[,1]>1.945)/20000 0.025


############################

simnull16<-parallel::mclapply(1:repn,function(x) {
  # print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=224,ptrue=c(0.7,0.7),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull16,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull16.Rdata')
#sum(do.call(rbind,simnull16)[,1]>1.964)/20000 0.025

############################

simnull17<-parallel::mclapply(1:repn,function(x) {
  #  print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=816,ptrue=c(0.75,0.75),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull17,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull17.Rdata')
#sum(do.call(rbind,simnull17)[,1]>1.9398)/20000 0.02495


#########################

simnull18<-parallel::mclapply(1:repn,function(x) {
  #  print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=168,ptrue=c(0.8,0.8),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)

save(simnull18,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull18.Rdata')
#sum(do.call(rbind,simnull18)[,1]>1.95)/20000 0.025



#########################

simnull19<-parallel::mclapply(1:repn,function(x) {
  # print(x)
  simflgi(jj=jj,x=x,vTimeToOutcome1=0,I0=matrix(1,nrow=2,2),K=2,crit=0.025,noRuns2=100,
          Tsize=552,ptrue=c(0.85,0.85),block=20,rule='Controlled FLGI',ztype='unpooled')
},mc.cores = 66)


save(simnull19,file='/nesi/project/uoa03821/CFLGI1/two_arms/delayed_response_0/df_0_995/block_size_20/simnull19.Rdata')
#sum(do.call(rbind,simnull19)[,1]>1.983)/20000 0.025
stopCluster(cluster)



